\documentclass{article}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref} 
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\begin{document}
\title{Prototipo de Lenguaje y Compilador para modelar redes AD-HOC usando agentes dispersos: \textit{Lenguaje ADD}}
\author{Joseph Alegandro Gallego Mejía\\
Sergio Edmundo Pérez Fonseca\\
Jhon Fredy Ramírez Guzmán}
\date{20 de enero, 2013}
\maketitle

\section{Gramática}
La gramática de nuestro lenguaje propuesto es una gramática \textit{LL1}, donde la primera \textit{L} hace alusión al hecho de que el flujo de terminales se lee de izquierda a derecha, accediendo a la entrada por su izquierda (\textit{Left}). La segunda \textit{L} se refiere a que el método de análisis predictivo construye una derivación a izquierdas, y 
\section{Identificación de Tokens}
\section{Arboles sintácticos}

\section{¿Qué es Pyro?}
Pyro significa \textbf{Py}thon \textbf{R}emote \textbf{O}bject, es una líbreria que permite construir aplicaciones, en las cuales los objetos pueden comunicarse entre ellos a través de una red, con un mínimo esfuerzo de programación. Con ayuda de esta líbreria Se puede hacer el llamado a los métodos de Python normalmente, con casi todos los posibles tipo de parámetros y valores de retorno, y Pyro se encarga de localizar el objeto correcto en el computador correcto para ejecutar el método.\\

Pyro está diseñado para ser muy fácil de usar, y generalmente no interponerse en el camino. También provee un conjunto de características poderosas que permiten construir aplicaciones distribuidas rápidamente y sin mucho esfuerzo. Pyro está desarrollada 100\% en Python puro y por lo tanto puede ser ejecutado en muchas plataformas y versiones de Python, incluyendo \textbf{Python 2.x}, \textbf{Python 3.x}, \textbf{IronPython}, \textbf{Jython 2.7+} and \textbf{Pypy}.\\

\begin{itemize}
\item Pyro es propiedad de Irmen de Jong \href{mailto:irmen@razorvine.net}{irmen@razorvine.net} - \url{http://www.razorvine.net}
\item El repositorio con el código fuente se encuentra en GitHub: \url{http://github.com/irmen/Pyro4}
\item La documentación de la librería se puede encontrar en: \url{http://pythonhosted.org/Pyro4/}
\item Pyro puede ser encontrado en \textbf{Pypi} como \href{https://pypi.python.org/pypi/Pyro4/}{Pyro4}
\end{itemize}

\section{Un poco de historia}
Pyro fue iniciado en 1998, hace más de diez años, cuando la tecnología de invocación de métodos remotos, tales como \textit{RMI} de Java y \textit{CORBA}, eran muy populares. El autor, quería algo así en Python, y como no había nada disponible, entonces decidió escribir el suyo propio. En el transcurso de los años lentamente se le fueron añadiendo nuevas características hasta la versión 3.10. En ese punto, era claro que el código base se había vuelto un poco viejo y no permitía la adición de nuevas características de una manera fácil, entonces, para inicios de 2010 se dió origen a Pyro4, escrito totalmente desde cero. Después de un par de versiones Pyro4 llegó a ser lo suficientemente estable para convertirse en la nueva versión "principal".\\

Pyro es el nombre del paquete de la versión antigua (\textit{3.x}) de Pyro. Pyro4 es el nombre del nuevo paquete, es decir, la versión actual. Su API y comportamiento es similar a Pyro 3.x, pero no es compatible hacia atras. Por ello, para evitar conflictos, la nueva versión de Pyro tiene un nombre diferente.

\section{Documentación de clases}
A continuación se presenta la descripción del comportamiento de cada una de los archivos del proyecto, así como el una descripción del objetivo que se persigue en cada método, incluyendo la descripción de sus parámetros de entrada, y sus parámetros de salida que retorna una vez termina su ejecución.

\subsection{Agente.py}
Representa un agente en el sistema. Está conformado por un componente de \textbf{Racionalidad}, y un componente de \textbf{Movilidad}, tiene la característica de dispersarse en la red, esto es, mover cada una de sus componentes a otros nodos en la red, cada cierto intervalo de tiempo, determinado por una función de distribución de probabilidad.\\

\begin{lstlisting}
import Pyro4
import threading
import time

class Agente(object):
    
    tipoMovilidad = ["constante","uniforme","exponencial"]    
    
    def __init__(self,nombre, movilidadId, racionalidadId, hostUri):
        self.hostUri = hostUri
        self.nombre = nombre
        self.movilidadId = movilidadId
        self.racionalidadId = racionalidadId
        thread = threading.Thread(target = self.wait2Seconds, args = [])
        thread.start()

    def getMovilidadId(self):
        return self.movilidadId

    def getRacionalidadId(self):
        return self.racionalidadId
        
    def getNombre(self):
        return self.nombre
        
    def getType(self):
        return 'head'

    def getPyroId(self):
        return str(self._pyroId)

    def doIt(self):
        ##place some call to legs and arms
        racionalidadUri = Pyro4.Proxy(self.hostUri).resolve(self.racionalidadId)
        movilidadUri =  Pyro4.Proxy(self.hostUri).resolve(self.movilidadId)
        if (racionalidadUri == False or movilidadUri == False):
            return 'Algo esta perdido'
        racionalidad = Pyro4.Proxy(racionalidadUri)
        movilidad = Pyro4.Proxy(movilidadUri)
        return [racionalidad.sayArms(), movilidad.sayLegs()]
\end{lstlisting}

\subsubsection*{\textbf{Métodos}}

\subsubsection{\textbf{init}(\textit{nombre}, \textit{movilidadId}, \textit{racionalidadId}, \textit{hostUri})}
Es el constructor de la clase, y a través de este método se permite instanciar objetos de esta clase.
\begin{lstlisting}
def __init__(self,nombre, movilidadId, racionalidadId, hostUri):
	self.hostUri = hostUri
	self.nombre = nombre
	self.movilidadId = movilidadId
	self.racionalidadId = racionalidadId
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre con el que se identifica el Agente en la red, debe ser único.
\item \textit{movilidadId}: Identificador del objeto que representa el componente correspondiente a la capacidad del agente de moverse en la red.
\item \textit{racionalidadId}: Identificador del objeto que representa el componente correspondiente a la capacidad del agente de tomar decisiones.
\item \textit{hostUri}: Identificador de recurso uniforme del \textit{Host} donde está alojado el agente en un instante de tiempo específico.
\end{itemize}
\subsubsection{\textbf{getMovilidad}()}
Permite a los demás objetos en la red obtener el identificador del objeto de la movilidad del agente.
\begin{lstlisting}
def getMovilidadId(self):
	return self.movilidadId
\end{lstlisting}
\subsubsection*{Retorno}
Retorna el identificador del objeto que representa el componente correspondiente a la capacidad del agente de moverse en la red.
\subsubsection{\textbf{getRacionalidad}()}
Permite a los demás objetos en la red obtener el identificador del objeto de la racionalidad del agente.
\begin{lstlisting}
def getRacionalidadId(self):
	return self.racionalidadId
\end{lstlisting}
\subsubsection*{Retorno}
Retorna el identificador del objeto que representa el componente correspondiente a la capacidad del agente de tomar decisiones.
\subsubsection{\textbf{getNombre}()}
Permite a los demás objetos en la red obtener el nombre del agente.
\begin{lstlisting}
def getNombre(self):
	return self.nombre
\end{lstlisting}
\subsubsection*{Retorno}
Retorna el nombre con el que se puede identificar el agente en la red.
\subsubsection{\textbf{getType}()}
Permite a los demás objetos en la red reconocer si este objeto es la cabeza (componente fundamental) del agente.
\begin{lstlisting}
def getType(self):
	return 'head'
\end{lstlisting}
\subsubsection*{Retorno}
Retorna la cadena de texto "\textit{head}" que indica que este objeto es la cabeza del agente.
\subsubsection{\textbf{getPyroId}()}
Permite a los demás objetos en la red obtener el identificador único del agente en el daemon.
\begin{lstlisting}
def getPyroId(self):
	return str(self._pyroId)
\end{lstlisting}
\subsubsection*{Retorno}
Retorna el identificador único del agente.
\subsubsection{\textbf{doIt}()}
Permite identificar en que host de la red se encuentra el componente de racionalidad del agente, y en que host de la red se encuentra el componente de movilidad del agente.
\begin{lstlisting}
def doIt(self):
	##place some call to legs and arms
	racionalidadUri = Pyro4.Proxy(self.hostUri).resolve(self.racionalidadId)
	movilidadUri =  Pyro4.Proxy(self.hostUri).resolve(self.movilidadId)
	if (racionalidadUri == False or movilidadUri == False):
		return 'Algo esta perdido'
	racionalidad = Pyro4.Proxy(racionalidadUri)
	movilidad = Pyro4.Proxy(movilidadUri)
	return [racionalidad.sayArms(), movilidad.sayLegs()]
\end{lstlisting}
\subsubsection*{Retorno}
Retorna una lista, con dos elementos: una cadena de texto con la ubicación en la red del componente de racionalidad, y una cadena de texto con la ubicación en la red del componente de movilidad. Si no encuentra alguno de los componentes que conforman el agente, se retorna "Algo está perdido".
\subsection{ComunidadAgentes.py}
Representa una comunidad de agentes para un servicio específico, es decir, una comunidad de agentes es un conjunto de agentes que tienen la responsabilidad de garantizar la prestación de un sevicio determinado entre uno o más dispositivos en la red.
\begin{lstlisting}
from Agente import Agente
from Servicio import Servicio

import Pyro4

# we're using custom classes, so need to use pickle
Pyro4.config.SERIALIZER='pickle'

# we're using custom classes, so need to use pickle
Pyro4.config.SERIALIZERS_ACCEPTED.add('pickle')

class ComunidadAgentes(object):
    idAgente = 1
    def __init__(self,nombre):
        self.__nombre = nombre
        ComunidadAgentes.idAgente+=1
        self.agente = {}
        
    def setServicio(self,servicio):
        print "Inicializo servicio"
        self.servicio = servicio
        
    def getServicio(self):
        return self.servicio
        
    def getNombre(self):
        return self.__nombre
        
    def addAgente(self,agente,nombre):
        self.agente[nombre] = agente
        
    def getAgente(self,nombre):
        return self.agente[nombre]
\end{lstlisting}
\subsubsection*{Métodos}
\subsubsection{\textbf{init}(\textit{nombre})}
Es el constructor de la clase, y a través de este método se permite instanciar objetos de esta clase.
\begin{lstlisting}
def __init__(self,nombre):
	self.__nombre = nombre
	ComunidadAgentes.idAgente+=1
	self.agente = {}
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre con el que se identifica la comunidad de agentes en la red, debe ser único.
\end{itemize}
\subsubsection{\textbf{setServicio}(\textit{servicio})}
Permite asignar el servicio que la comunidad de agentes debe proveer.
\begin{lstlisting}
def setServicio(self,servicio):
	print "Inicializo servicio"
	self.servicio = servicio
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{servicio}: Nombre del servicio que la comunidad de agentes debe proveer
\end{itemize}
\subsubsection{\textbf{getServicio}()}
Permite a los demás objetos en la red obtener el nombre del servicio que la comunidad de agentes suministra.
\begin{lstlisting}
def getServicio(self):
	return self.servicio
\end{lstlisting}
\subsubsection*{Retorno}
Retorna el nombre del servicio que la comunidad de agentes debe proveer a los dispositivos en la red
\subsubsection{\textbf{getNombre}()}
Permite a los demás objetos en la red obtener el nombre de la comunidad de agentes.
\begin{lstlisting}
def getNombre(self):
    return self.__nombre
\end{lstlisting}
\subsubsection*{Retorno}
Retorna el nombre con el que se puede identificar la comunidad de agentes en la red.
\subsubsection{\textbf{addAgente}(\textit{agente},\textit{nombre})}
Permite agregar un nuevo agente a la comunidad de agentes con nombre "\textit{nombre}".
\begin{lstlisting}
def addAgente(self,agente,nombre):
	self.agente[nombre] = agente
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{agente}: Instancia de la clase Agente. Representa el nuevo agente que será agregado a la comunidad de agentes.
\item \textit{nombre}: Nombre del nuevo agente que formará parte de la comunidad de agentes.
\end{itemize}
\subsubsection{\textbf{getAgente}()}
Permite a los demás objetos en la red obtener el agente cuyo nombre coincide con "\textit{nombre}", y que a su vez hace parte de la comunidad de agentes.
\begin{lstlisting}
def getAgente(self,nombre):
    return self.agente[nombre]
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre del agente que se desea buscar en la comunidad de agentes.
\end{itemize}
\subsubsection*{Retorno}
Retorna un objeto de la clase agente, el cuál es el resultado de la búsquedad en la comunidad de agentes de un agente que tenga como nombre "\textit{nombre}".
\subsection{CrearHost.py}
Esta clase se encarga de publicar una instancia de la clase "\textit{Host}" (Objeto python regular) para que pueda ser accesible remotamente, es decir convierte dicho objeto en un "\textbf{Objeto Pyro}".\\

De manera muy sencilla el procedimiento es el siguiente: se crean uno o más objetos, los cuales se desean publicar como objetos Pyro, se crea un "\textit{daemon}", se registran los objetos con este, y se inicia el ciclo de las peticiones de dicho daemon.
\begin{lstlisting}
import Pyro4
from Agente import Agente
from Servicio import Servicio
from ComunidadAgentes import ComunidadAgentes
from Host import Host

HostLogik = Host("Logik")
#Metodo pyro
#Se crea de la manera simple con serveSimple, sin tener en cuenta el host.
Pyro4.Daemon.serveSimple({
    HostLogik : "host." + str(HostLogik.getNombre())
},host="0.0.0.0")
\end{lstlisting}
\subsubsection*{Métodos}
\subsubsection{\textbf{serveSimple}(\textit{objetos},\textit{host})}
Permite exponer un objeto regular de Python como un objeto Pyro, de tal manera que sea accesible remotamente a los demás objetos en la red.
\begin{lstlisting}
Pyro4.Daemon.serveSimple({
    HostLogik : "host." + str(HostLogik.getNombre())
},host="0.0.0.0")
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{objects}: Es un diccionario que contiene los objetos que serán expuestos, los cuales serán registrados como llave, y los nombres de dichos objetos, que serán registrados como valores.
\item \textit{host}: Es el host donde se iniciará el daemon.
\end{itemize}
\subsection{Host.py}
Representa un host en el sistema, es decir, un nodo de la red (instancias de esta clase). Tiene la propiedad de almacenar en su interior una lista de los diferentes componentes que conforman un agente (cabeza, movilidad y racionalidad), así como una lista de los name server que define Pyro.
\begin{lstlisting}
import Pyro4
import Agente
import Racionalidad
import Movilidad
import random

class Host(object):

    def getNombre(self):
        return self.nombre
    
    def __init__(self , nombre):   
        self.nombre = nombre
        self.listNS = {}
        self.listAgentes = {}
        self.listMovilidad = {}
        self.listRacionalidad = {}
    
    def resolve(self, name):#had to add this methos on the host, so it can act sorta like a NameServer
        ret = self.find(name)
        if(ret == False):
            print('Precaucion!: objeto no esta en el host. Esto puede afectar el rendimiento.')
            for nameServer,nameServer_uri in self.listNS.items():
                try:                
                    findHost = Pyro4.Proxy(Pyro4.Proxy(nameServer_uri).list()['host.' + self.nombre])
                    ret = findHost.find(name)
                except:
                    print "Error: no se localizo el host"
                    ret = False
                if(ret!=False):
                    return ret
        return ret


    
    def find(self, name):
        """ returns uri of object or false """
        try:
            return self.listAgentes[name]
        except:
            try:
                return self.listMovilidad[name]
            except:
                try:
                    return self.listRacionalidad[name]
                except:
                    return False    
    

    def getListNS(self):
        return self.listNS;
        
    def addNS(self,ip,ns):
        """    """
        try:
            if self.listNS[ip]:
                print "El NS existe en la lista"
        except KeyError:
            self.listNS[ip] = "PYRO:Pyro.NameServer@" + str(ip)  +":"+ str(ns.port)
            
    def setListNS(self, lNS):
        self.listNS = lNS
        
    def deleteNS(self,nombre):
        """    """
        try:
            del self.listNS[nombre]
            print "Se elimino el NS de la lista"
        except KeyError:
            print "No existe el NS en la lista"
        
    def getListAgentes(self):  
        """  """
        return self.listAgentes;
    
    def addAgente(self,agente, create = True):
        if(self.resolve(agente) == False):
            movilidadId = 'legs_' + agente
            racionalidadId = 'arms_' + agente
            hostUri = 'PYRO:' + self._pyroId + '@' + self._pyroDaemon.locationStr
            agent = Agente.Agente(agente, movilidadId, racionalidadId, hostUri)
            if(create):
                self.addRacionalidad(racionalidadId)
                self.addMovilidad(movilidadId)

            print('Adding head ' + agent.getNombre() + ' to Daemon in ' + str(self._pyroDaemon.locationStr))
            uri = self._pyroDaemon.register(agent)
            self.listAgentes[agent.getNombre()] = uri.asString()
            return uri.asString()
        else:
            #Corregir
            return self.resolve(agente)

    def setListAgente(self, lAgente):
        self.listAgentes = lAgente
        
    def deleteAgente(self,nombre):
        uri = self.listAgentes[nombre]
        print('Removing ' + nombre + ' from Daemon at ' + self._pyroDaemon.locationStr)
        self._pyroDaemon.unregister(uri[5:uri.find('@')])
        self.listAgentes.pop(nombre)
            
    def getListMovilidad(self):
        """ """
        return self.listMovilidad;
        
    def addMovilidad(self,movilidadId): 
        movilidad = Movilidad.Movilidad(movilidadId)
        print('Adding Movility ' + movilidad.getId() + ' to Daemon in ' + str(self._pyroDaemon.locationStr))
        uri = self._pyroDaemon.register(movilidad)
        self.listMovilidad[movilidad.getId()] = uri.asString()

    def setListMovilidad(self, lMovilidad):
        self.listMovilidad = lMovilidad
        
    def deleteMovilidad(self,nombre):
        uri = self.listMovilidad[nombre]
        print('Removing ' + nombre + ' from Daemon at ' + self._pyroDaemon.locationStr)
        self._pyroDaemon.unregister(uri[5:uri.find('@')])
        self.listMovilidad.pop(nombre)
            
        
            
    def getListRacionalidad(self):
        return self.listRacionalidad

        
    def addRacionalidad(self,racionalidadId):
        racionalidad = Racionalidad.Racionalidad(racionalidadId)
        print('Adding rationality ' + racionalidad.getId() + ' to Daemon in ' + str(self._pyroDaemon.locationStr))
        uri = self._pyroDaemon.register(racionalidad)
        self.listRacionalidad[racionalidad.getId()] = uri.asString()
        
    def setListRacionalidad(self, lRacionalidad):
        self.listRacionalidad = lRacionalidad
            
    def deleteRacionalidad(self,nombre):
        uri = self.listRacionalidad[nombre]
        print('Removing ' + nombre + ' from Daemon at ' + self._pyroDaemon.locationStr)
        self._pyroDaemon.unregister(uri[5:uri.find('@')])
        self.listRacionalidad.pop(nombre)
     
    def moveAgente(self, nombre, hostTo):  
        try:
            uri = self.listAgentes[nombre]
            print('Moviendo ' + nombre + ' to ' + hostTo + '...')
            self.deleteAgente(nombre)
            newHost = Pyro4.Proxy(Pyro4.locateNS(hostTo).list()['host.' + self.nombre])
            return newHost.addAgente(nombre, False)
        except:
            print('No existe el agente en este Host')

    def moveMovilidad(self, nombre, hostTo):  
        try:
            uri = self.listMovilidad[nombre]
            print('Moviendo ' + nombre + ' to ' + hostTo + '...')
            self.deleteMovilidad(nombre)
            newHost = Pyro4.Proxy(Pyro4.locateNS(hostTo).list()['host.' + self.nombre])
            newHost.addMovilidad(nombre)
        except:
            print('No existe la movilidad en este Host')

    def moveRacionalidad(self, nombre, hostTo):  
        try:
            uri = self.listRacionalidad[nombre]
            print('Moviendo ' + nombre + ' to ' + hostTo + '...')
            self.deleteRacionalidad(nombre)
            newHost = Pyro4.Proxy(Pyro4.locateNS(hostTo).list()['host.' + self.nombre])
            newHost.addRacionalidad(nombre)
        except:
            print('No existe la racionalidad en este Host')

    def disperseAgente(self, agentId):
        agent = Pyro4.Proxy(self.listAgentes[agentId])
        movilidadId = agent.getMovilidadId()
        racionalidadId = agent.getRacionalidadId()
        self.moveMovilidad(movilidadId, random.sample(self.listNS.keys(), 1)[0])
        self.moveRacionalidad(racionalidadId, random.sample(self.listNS.keys(), 1)[0])
        return self.moveAgente(agentId, random.sample(self.listNS.keys(), 1)[0])
        
        
    #Servicio
    def searchHead(self, name):#had to add this methos on the host, so it can act sorta like a NameServer
        ret = self.findHead(name)
        if(ret == False):
            print('Precaucion!: Head del objeto no esta en el host. Esto puede afectar el rendimiento.')
            for nameServer,nameServer_uri in self.listNS.items():
                try:                
                    findHost = Pyro4.Proxy(Pyro4.Proxy(nameServer_uri).list()['host.' + self.nombre])
                    ret = findHost.findHead(name)
                except:
                    print "Error: no se localizo el host"
                    ret = False
                if(ret != False):
                    return [ret,Pyro4.Proxy(nameServer_uri).list()['host.' + self.nombre]]
        return ret
        
    
    def findHead(self, name):
        """ returns uri of object or false """
        try:
            return self.listAgentes[name]
        except:
            return False   
            
    def searchMovilidad(self, name):#had to add this methos on the host, so it can act sorta like a NameServer
        ret = self.findMovilidad(name)
        if(ret == False):
            print('Precaucion!: Movilidad del objeto no esta en el host. Esto puede afectar el rendimiento.')
            for nameServer,nameServer_uri in self.listNS.items():
                try:                
                    findHost = Pyro4.Proxy(Pyro4.Proxy(nameServer_uri).list()['host.' + self.nombre])
                    ret = findHost.findMovilidad(name)
                except:
                    print "Error: no se localizo el host"
                    ret = False
                if(ret != False):
                    return [ret,Pyro4.Proxy(nameServer_uri).list()['host.' + self.nombre]]
        return ret

    
    def findMovilidad(self, name):
        """ returns uri of object or false """
        try:
            return self.listMovilidad[name]
        except:
            return False   
            
    def searchRacionalidad(self, name):#had to add this methos on the host, so it can act sorta like a NameServer
        ret = self.findRacionalidad(name)
        if(ret == False):
            print('Precaucion!: Movilidad del objeto no esta en el host. Esto puede afectar el rendimiento.')
            for nameServer,nameServer_uri in self.listNS.items():
                try:                
                    findHost = Pyro4.Proxy(Pyro4.Proxy(nameServer_uri).list()['host.' + self.nombre])
                    ret = findHost.findRacionalidad(name)
                except:
                    print "Error: no se localizo el host"
                    ret = False
                if(ret != False):
                    return ret
        return ret
        
    
    def findRacionalidad(self, name):
        """ returns uri of object or false """
        try:
            return self.listRacionalidad[name]
        except:
            return False     
    
    #Funciones para la comunidad de agentes.
    def retrieveAgente(self, agentId):
        #Primero se recupera la cabeza o encabezado del agente.
        agent = self.searchHead(agentId)
        if(agent == False):
            print 'No se encontro el agente'
        else:
            print 'Moviendo el encabezado al host ' + self.nombre
            agent = self.moveAgente(agentId,self.listNS[self.nombre])
            movilidadId = Pyro4.Proxy(agent).getMovilidadId()
            [movilidad,hostMovilidad] = self.searchMovilidad(movilidadId)
            if(movilidad == False):
                print 'No se encontro la movilidad '
                print 'Dado que no se encontro la movilidad no se procedera a encontrar la racionalidad'
            else:
                self.moveMovilidad(movilidadId, self.listNS[self.nombre])
                racionalidadId = Pyro4.Proxy(agent).getRacionalidadId()
                try:
                    Pyro4.Proxy(hostMovilidad).getListMovilidad()[racionalidadId]
                    self.moveRacionalidad(racionalidadId,self.listNS[self.nombre])
                except:
                    'La racionalidad no se encuentra con la movilidad por lo tanto no se podra mover'
                    
        return agent
\end{lstlisting}
\subsubsection*{Métodos}
\subsubsection{\textbf{getNombre}()}
Permite a los demás objetos en la red obtener el nombre del host.
\begin{lstlisting}
def getNombre(self):
	return self.nombre
\end{lstlisting}
\subsubsection*{Retorno}
Retorna el nombre con el que se puede identificar el host en la red.
\subsubsection{\textbf{init}(\textit{nombre})}
Es el constructor de la clase, y a través de este método se permite instanciar objetos de esta clase.
\begin{lstlisting}
def __init__(self , nombre):   
	self.nombre = nombre
    self.listNS = {}
	self.listAgentes = {}
    self.listMovilidad = {}
	self.listRacionalidad = {}
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre con el que se identifica el host en la red, debe ser único.
\end{itemize}
\subsubsection{\textbf{resolve}(\textit{name})}
Realiza una búsqueda en todos los nodos que conforman la red permitiendo a los demás objetos en la red obtener el identificador de recurso uniforme (uri) del objeto cuyo nombre coincida con "\textit{name}".
\begin{lstlisting}
def resolve(self, name):
	ret = self.find(name)
	if(ret == False):
		print('Precaucion!: objeto no esta en el host. Esto puede afectar el rendimiento.')
		for nameServer,nameServer_uri in self.listNS.items():
			try:                
				findHost = Pyro4.Proxy(Pyro4.Proxy(nameServer_uri).list()['host.' + self.nombre])
				ret = findHost.find(name)
			except:
				print "Error: no se localizo el host"
				ret = False
			if(ret!=False):
				return ret
	return ret
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{name}: Nombre del objeto que se desea encontrar en la red.
\end{itemize}
\subsubsection*{Retorno}
Retorna el identificador de recurso uniforme (uri) del objeto cuyo nombre coincida con el parámetro "\textit{name}". Si no se encuentra en la red dicho objeto, es decir, en ningún host, entonces se retorna Falso.
\subsubsection{\textbf{find}(\textit{name})}
Realiza una búsqueda en este host permitiendo a los demás objetos en la red obtener el identificador de recurso uniforme (uri) del objeto cuyo nombre coincida con "\textit{name}".
\begin{lstlisting}
def find(self, name):
	try:
		return self.listAgentes[name]
	except:
		try:
			return self.listMovilidad[name]
		 except:
			try:
				return self.listRacionalidad[name]
			except:
				return False
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{name}: Nombre del objeto que se desea encontrar en el host.
\end{itemize}
\subsubsection*{Retorno}
Retorna el identificador de recurso uniforme (uri) del objeto cuyo nombre coincida con el parámetro "\textit{name}" que se encuentre ubicado en el host. Si no se encuentra en el host dicho objeto se retorna Falso.
\subsubsection{\textbf{getListNS}()}
Permite a los demás objetos en la red obtener la lista de los name servers definida por Pyro. En cada name server se encuentra la direccion de cada uno de los hosts que se encuentran distribuidos en la red.
\begin{lstlisting}
def getListNS(self):
	return self.listNS;
\end{lstlisting}
\subsubsection*{Retorno}
Retorna la lista de los name server existentes hasta el momento.
\subsubsection{\textbf{addNS}(\textit{host}, \textit{ns})}
Añade a la lista de name servers del host un nuevo name server.
\begin{lstlisting}
def addNS(self,ip,ns):
	try:
		if self.listNS[ip]:
			print "El NS existe en la lista"
	except KeyError:
		self.listNS[ip] = "PYRO:Pyro.NameServer@" + str(ip)  +":"+ str(ns.port)
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{host}: Dirección IP del host donde esta corriendo el name server "\textit{ns}"
\item \textit{ns}: Name server que será agregado a la lista de name servers del host.
\end{itemize}
\subsubsection{\textbf{setListNS}(\textit{lNS})}
Permite asignar la lista de name servers al host.
\begin{lstlisting}
def setListNS(self, lNS):
	self.listNS = lNS
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{lNS}: Lista de name servers que se quiere asignar a este host.
\end{itemize}
\subsubsection{\textbf{deleteNS}(\textit{nombre})}
Permite eliminar el name server con el nombre "\textit{nombre}" de la lista de name servers del host. Si no existe el name server en la lista, se produce una excepción.
\begin{lstlisting}
def deleteNS(self,nombre)
	try:
		del self.listNS[nombre]
		print "Se elimino el NS de la lista"
	except KeyError:
		print "No existe el NS en la lista"
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre del name server que se quiere remover de la lista de name servers del host.
\end{itemize}
\subsubsection{\textbf{getListAgentes}()}
Permite a los demás objetos en la red obtener la lista de las cabezas de los agentes que se encuentran en el host.
\begin{lstlisting}
def getListAgentes(self):
	return self.listAgentes;
\end{lstlisting}
\subsubsection*{Retorno}
Retorna la lista de las cabezas de los agentes que se encuentran alojados en el host.
\subsubsection{\textbf{addAgente}(\textit{agente}, \textit{create} = \textbf{True})}
Adiciona a la lista de agentes el objeto "\textit{agente}". Si el agente ya existe en la red se retorna su identificador de recurso uniforme, si no existe, el agente se expone como objeto Pyro y se retorna la \textit{uri} resultante.
\begin{lstlisting}
def addAgente(self,agente, create = True):
	if(self.resolve(agente) == False):
		movilidadId = 'legs_' + agente
		racionalidadId = 'arms_' + agente
		hostUri = 'PYRO:' + self._pyroId + '@' + self._pyroDaemon.locationStr
		agent = Agente.Agente(agente, movilidadId, racionalidadId, hostUri)
		if(create):
			self.addRacionalidad(racionalidadId)
			self.addMovilidad(movilidadId)

		print('Adding head ' + agent.getNombre() + ' to Daemon in ' + str(self._pyroDaemon.locationStr))
		uri = self._pyroDaemon.register(agent)
		self.listAgentes[agent.getNombre()] = uri.asString()
		return uri.asString()
	else:
		#Corregir
		return self.resolve(agente)
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{agente}: Instancia de la clase objeto que será adicionada a la lista de agentes del host.
\item \textit{create}: Parámetro que indica si se debe crear los componentes de movilidad y racionalidad del agente, y añadirlos a la lista de movilidades y racionalidades del host respectivamente. Por defecto es \textbf{True}.
\end{itemize}
\subsubsection*{Retorno}
Retorna el identificador de recurso uniforme del objeto (uri) "\textit{agente}" que ha sido agregado a la lista de agentes en el host.
\subsubsection{\textbf{setListAgente}(\textit{lAgente})}
Permite asignar la lista de agentes al host.
\begin{lstlisting}
def setListAgente(self, lAgente):
	self.listAgentes = lAgente
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{lAgente}: Lista de agentes que seran asignadas al host.
\end{itemize}
\subsubsection{\textbf{deleteAgente}(\textit{nombre})}
Permite eliminar el agente cuyo nombre coincida con "\textit{nombre}" de la lista de agentes del host.
\begin{lstlisting}
def deleteAgente(self,nombre):
	uri = self.listAgentes[nombre]
    print('Removing ' + nombre + ' from Daemon at ' + self._pyroDaemon.locationStr)
	self._pyroDaemon.unregister(uri[5:uri.find('@')])
    self.listAgentes.pop(nombre)
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre del agente que será removido de la lista de agentes del host.
\end{itemize}
\subsubsection{\textbf{getListMovilidad}()}
Permite a los demás objetos en la red obtener la lista de los componentes de movilidad de los agentes existentes en la red, que se encuentran en el host.
\begin{lstlisting}
def getListMovilidad(self):
	return self.listMovilidad;
\end{lstlisting}
\subsubsection*{Retorno}
Retorna la lista de los componentes de movilidad de los agentes que se encuentran alojados en el host.
\subsubsection{\textbf{addMovilidad}(\textit{movilidadId})}
Adiciona a la lista de componentes de movilidad de los agentes el componente de movilidad que coincida con con el id "\textit{movilidadId}".
\begin{lstlisting}
def addMovilidad(self,movilidadId): 
	movilidad = Movilidad.Movilidad(movilidadId)
	print('Adding Movility ' + movilidad.getId() + ' to Daemon in ' + str(self._pyroDaemon.locationStr))
	uri = self._pyroDaemon.register(movilidad)
	self.listMovilidad[movilidad.getId()] = uri.asString()
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{movilidadId}: Id del componente de movilidad que se desea agregar a la lista de componentes de movilidad en el host.
\end{itemize}
\subsubsection{\textbf{setListMovilidad}(\textit{lMovilidad})}
Permite asignar la lista de componentes de movilidad de los agentes al host.
\begin{lstlisting}
def setListMovilidad(self, lMovilidad):
	self.listMovilidad = lMovilidad
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{lMovilidad}: Lista de los componentes de movilidad que serán asignados al host.
\end{itemize}
\subsubsection{\textbf{deleteMovilidad}(\textit{nombre})}
Permite eliminar el componente de movilidad cuyo nombre coincida con "\textit{nombre}" de la lista de componentes de movilidad del host.
\begin{lstlisting}
def deleteMovilidad(self,nombre):
	uri = self.listMovilidad[nombre]
    print('Removing ' + nombre + ' from Daemon at ' + self._pyroDaemon.locationStr)
	self._pyroDaemon.unregister(uri[5:uri.find('@')])
    self.listMovilidad.pop(nombre)
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre del componente de movilidad que será removido de la lista de componentes de movilidad del host.
\end{itemize}
\subsubsection{\textbf{getListRacionalidad}()}
Permite a los demás objetos en la red obtener la lista de los componentes de racionalidad de los agentes existentes en la red, que se encuentran en el host.
\begin{lstlisting}
def getListRacionalidad(self):
	return self.listRacionalidad
\end{lstlisting}
\subsubsection*{Retorno}
Retorna la lista de los componentes de racionalidad de los agentes que se encuentran alojados en el host.
\subsubsection{\textbf{addRacionalidad}(\textit{racionalidadId})}
Adiciona a la lista de componentes de racionalidad de los agentes el componente de racionalidad que coincida con con el id "\textit{racionalidadId}".
\begin{lstlisting}
def addRacionalidad(self,racionalidadId):
	racionalidad = Racionalidad.Racionalidad(racionalidadId)
    print('Adding rationality ' + racionalidad.getId() + ' to Daemon in ' + str(self._pyroDaemon.locationStr))
	uri = self._pyroDaemon.register(racionalidad)
    self.listRacionalidad[racionalidad.getId()] = uri.asString()
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{racionalidadId}: Id del componente de racionalidad que se desea agregar a la lista de componentes de racionalidad en el host.
\end{itemize}
\subsubsection{\textbf{setListRacionalidad}(\textit{lRacionalidad})}
Permite asignar la lista de componentes de racionalidad de los agentes al host.
\begin{lstlisting}
def setListRacionalidad(self, lRacionalidad):
	self.listRacionalidad = lRacionalidad
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{lRacionalidad}: Lista de los componentes de racionalidad que serán asignados al host.
\end{itemize}
\subsubsection{\textbf{deleteRacionalidad}(\textit{nombre})}
Permite eliminar el componente de racionalidad cuyo nombre coincida con "\textit{nombre}" de la lista de componentes de racionalidad del host.
\begin{lstlisting}
def deleteRacionalidad(self,nombre):
	uri = self.listRacionalidad[nombre]
	print('Removing ' + nombre + ' from Daemon at ' + self._pyroDaemon.locationStr)
	self._pyroDaemon.unregister(uri[5:uri.find('@')])
	self.listRacionalidad.pop(nombre)
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre del componente de racionalidad que será removido de la lista de componentes de movilidad del host.
\end{itemize}
\subsubsection{\textbf{moveAgente}(\textit{nombre}, \textit{hostTo})}
Permite mover el agente, de la lista de agentes del host, cuyo nombre coincida con ``\textit{nombre}'' al host de destino "\textit{hostTo}". Si el agente no existe en el host se lanza una excepción.
\begin{lstlisting}
def moveAgente(self, nombre, hostTo):  
	try:
		uri = self.listAgentes[nombre]
		print('Moviendo ' + nombre + ' to ' + hostTo + '...')
		self.deleteAgente(nombre)
		newHost = Pyro4.Proxy(Pyro4.locateNS(hostTo).list()['host.' + self.nombre])
		return newHost.addAgente(nombre, False)
	except:
		print('No existe el agente en este Host')
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre del agente que se desea mover.
\item \textit{hostTo}: Host de destino al cual se desea mover el agente.
\end{itemize}
\subsubsection*{Retorno}
Retorna el nuevo identificador de recurso uniforme (uri) del agente.
\subsubsection{\textbf{moveMovilidad}(\textit{nombre}, \textit{hostTo})}
Permite mover el componente de movilidad, de la lista de componentes de movilidad del host, cuyo nombre coincida con ``\textit{nombre}'' al host de destino "\textit{hostTo}". Si el componente de movilidad no existe en el host se lanza una excepción.
\begin{lstlisting}
def moveMovilidad(self, nombre, hostTo):  
	try:
		uri = self.listMovilidad[nombre]
		print('Moviendo ' + nombre + ' to ' + hostTo + '...')
		self.deleteMovilidad(nombre)
		newHost = Pyro4.Proxy(Pyro4.locateNS(hostTo).list()['host.' + self.nombre])
		newHost.addMovilidad(nombre)
	except:
		print('No existe la movilidad en este Host')
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre del componente de movilidad que se desea mover.
\item \textit{hostTo}: Host de destino al cual se desea mover el componente de movilidad.
\end{itemize}
\subsubsection{\textbf{moveRacionalidad}(\textit{nombre}, \textit{hostTo})}
Permite mover el componente de racionalidad, de la lista de componentes de racionalidad del host, cuyo nombre coincida con ``\textit{nombre}'' al host de destino "\textit{hostTo}". Si el componente de racionalidad no existe en el host se lanza una excepción.
\begin{lstlisting}
def moveRacionalidad(self, nombre, hostTo):  
	try:
		uri = self.listRacionalidad[nombre]
		print('Moviendo ' + nombre + ' to ' + hostTo + '...')
        self.deleteRacionalidad(nombre)
		newHost = Pyro4.Proxy(Pyro4.locateNS(hostTo).list()['host.' + self.nombre])
        newHost.addRacionalidad(nombre)
	except:
    	print('No existe la racionalidad en este Host')
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{nombre}: Nombre del componente de racionalidad que se desea mover.
\item \textit{hostTo}: Host de destino al cual se desea mover el componente de racionalidad.
\end{itemize}
\subsubsection{\textbf{disperseAgente}(\textit{agentId})}
Permite dispersar el agente identificado con id "\textit{agentId}" en la red, es decir, los componentes del agente (cabeza, movilidad y racionalidad) son enviados aleatoriamente a otros host en la red.
\begin{lstlisting}
def disperseAgente(self, agentId):
	agent = Pyro4.Proxy(self.listAgentes[agentId])
    movilidadId = agent.getMovilidadId()
	racionalidadId = agent.getRacionalidadId()
    self.moveMovilidad(movilidadId, random.sample(self.listNS.keys(), 1)[0])
	self.moveRacionalidad(racionalidadId, random.sample(self.listNS.keys(), 1)[0])
    return self.moveAgente(agentId, random.sample(self.listNS.keys(), 1)[0])
\end{lstlisting}
\subsubsection*{Parámetros}
\begin{itemize}
\item \textit{agentId}: Identificador del agente que será dispersado en la red.
\end{itemize}
\subsubsection*{Retorno}
Retorna el nuevo identificador de recurso uniforme (uri) del agente que ha sido dispersado.
\end{document}